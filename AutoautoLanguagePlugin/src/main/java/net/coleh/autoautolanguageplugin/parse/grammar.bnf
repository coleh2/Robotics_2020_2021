{
  parserClass="net.coleh.autoautolanguageplugin.parse.AutoautoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Autoauto"
  psiImplClassSuffix="Impl"
  psiPackage="net.coleh.autoautolanguageplugin.parse"
  psiImplPackage="net.coleh.autoautolanguageplugin.parse.impl"

  elementTypeHolderClass="net.coleh.autoautolanguageplugin.parse.AutoautoTypes"
  elementTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoElementType"
  tokenTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoTokenType"

  psiImplUtilClass="net.coleh.autoautolanguageplugin.parse.AutoautoPsiUtilImpl"
}

autoautoFile ::=  commentOpportunity* labeledStatepath+ commentOpportunity*

commentOpportunity ::= comment [WHITESPACE_RANGE]

labeledStatepath ::= commentOpportunity* STATEPATH_LABEL_ID COLON commentOpportunity* statepath commentOpportunity* {methods=[getLabel]}


statepath ::=  commentOpportunity* (state SEMICOLON)* state [SEMICOLON] commentOpportunity*

state ::=  commentOpportunity* (statement COMMA)* statement [COMMA] commentOpportunity*

statement ::=  commentOpportunity*  (afterStatement|functionCallStatement|gotoStatement|ifStatement|letStatement|nextStatement|skipStatement)  commentOpportunity*

afterStatement ::= AFTER unitValue statement

functionCallStatement ::= functionCall

gotoStatement ::= GOTO IDENTIFIER

ifStatement ::= IF OPEN_PAREN boolean CLOSE_PAREN statement

letStatement ::= LET variableReference commentOpportunity* EQUALS commentOpportunity* value

nextStatement ::= NEXT

skipStatement ::= SKIP NUMERIC_VALUE

value ::= commentOpportunity*  [MINUS] (arrayLiteral | boolean | functionCall | NUMERIC_VALUE | stringLiteral | unitValue | variableReference) commentOpportunity*

nonBooleanValue ::=  commentOpportunity* (arrayLiteral | functionCall | NUMERIC_VALUE | stringLiteral | unitValue | variableReference) commentOpportunity*

variableReference ::= IDENTIFIER

arrayLiteral ::= "[" [argumentList] "]"

boolean ::= (nonBooleanValue comparisonOperator nonBooleanValue) | functionCall

comparisonOperator ::= COMPARE_LT | COMPARE_LTE | COMPARE_EQ | COMPARE_NEQ | COMPARE_GTE | COMPARE_GT

functionCall ::= IDENTIFIER commentOpportunity* OPEN_PAREN [argumentList] CLOSE_PAREN

stringLiteral ::= QUOTE NON_QUOTE_CHARACTER* QUOTE

unitValue ::= NUMERIC_VALUE_WITH_UNIT

comment ::= blockComment | lineComment

blockComment ::= COMMENT_BEGIN COMMENT_TEXT* COMMENT_END

lineComment ::= LINE_COMMENT_BEGIN COMMENT_TEXT* LINE_COMMENT_END

argumentList ::= (value COMMA)* value
