{
  parserClass="net.coleh.autoautolanguageplugin.parse.AutoautoParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Autoauto"
  psiImplClassSuffix="Impl"
  psiPackage="net.coleh.autoautolanguageplugin.parse"
  psiImplPackage="net.coleh.autoautolanguageplugin.parse.impl"

  elementTypeHolderClass="net.coleh.autoautolanguageplugin.parse.AutoautoTypes"
  elementTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoElementType"
  tokenTypeClass="net.coleh.autoautolanguageplugin.parse.AutoautoTokenType"

  psiImplUtilClass="net.coleh.autoautolanguageplugin.parse.AutoautoPsiUtilImpl"
}

autoautoFile ::=  commentOpportunity* [frontMatter] commentOpportunity* labeledStatepath+ commentOpportunity*

frontMatter ::= DOLLAR_SIGN commentOpportunity* (frontMatterKeyValue COMMA)* frontMatterKeyValue commentOpportunity* DOLLAR_SIGN

frontMatterKeyValue ::= IDENTIFIER COLON commentOpportunity* value commentOpportunity*

commentOpportunity ::= comment [WHITESPACE_RANGE]

labeledStatepath ::= commentOpportunity* STATEPATH_LABEL_ID COLON commentOpportunity* statepath commentOpportunity* {methods=[getLabel]}


statepath ::=  commentOpportunity* (state SEMICOLON)* state [SEMICOLON] commentOpportunity*

state ::=  commentOpportunity* (statement COMMA)* statement [COMMA] commentOpportunity*

statement ::=  commentOpportunity*  (afterStatement|functionCallStatement|gotoStatement|ifStatement|letStatement|nextStatement|skipStatement)  commentOpportunity*

afterStatement ::= AFTER unitValue statement

functionCallStatement ::= functionCall

gotoStatement ::= GOTO IDENTIFIER

ifStatement ::= IF OPEN_PAREN boolean CLOSE_PAREN statement

letStatement ::= LET variableReference commentOpportunity* EQUALS commentOpportunity* value

nextStatement ::= NEXT

skipStatement ::= SKIP NUMERIC_VALUE

value ::= commentOpportunity*  (arithmeticValue | boolean) commentOpportunity*

valueInParens ::= commentOpportunity* OPEN_PAREN value CLOSE_PAREN commentOpportunity*

modulo ::= baseExpression [MODULUS baseExpression]
exponent ::= modulo [EXPONENTIATE modulo]
product ::= exponent [((MULTIPLY | DIVIDE) exponent)+]
sum ::= product [((PLUS | MINUS) product)+]
arithmeticValue ::= sum

baseExpression ::= commentOpportunity*  (arrayLiteral | functionCall | NUMERIC_VALUE | stringLiteral | unitValue | variableReference | valueInParens) commentOpportunity*

variableReference ::= IDENTIFIER

arrayLiteral ::= OPEN_SQUARE_BRACKET [argumentList] CLOSE_SQUARE_BRACKET

boolean ::= (arithmeticValue comparisonOperator arithmeticValue) | TRUE | FALSE

comparisonOperator ::= COMPARE_LT | COMPARE_LTE | COMPARE_EQ | COMPARE_NEQ | COMPARE_GTE | COMPARE_GT

functionCall ::= IDENTIFIER commentOpportunity* OPEN_PAREN [argumentList] CLOSE_PAREN

stringLiteral ::= QUOTE NON_QUOTE_CHARACTER* QUOTE

unitValue ::= NUMERIC_VALUE_WITH_UNIT

comment ::= blockComment | lineComment

blockComment ::= COMMENT_BEGIN COMMENT_TEXT* COMMENT_END

lineComment ::= LINE_COMMENT_BEGIN COMMENT_TEXT* LINE_COMMENT_END

argumentList ::= (value COMMA)* value
