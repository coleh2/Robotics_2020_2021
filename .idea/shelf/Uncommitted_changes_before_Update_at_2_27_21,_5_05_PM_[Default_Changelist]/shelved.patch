Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.auxilary;\n\nimport android.graphics.Color;\n\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\nimport com.qualcomm.robotcore.hardware.NormalizedRGBA;\nimport com.qualcomm.robotcore.hardware.SwitchableLight;\n\nimport org.firstinspires.ftc.teamcode.autonomous.*;\nimport org.firstinspires.ftc.teamcode.auxilary.*;\nimport org.firstinspires.ftc.teamcode.managers.*;\nimport org.firstinspires.ftc.teamcode.teleop.*;\n\npublic class ColorSensor {\n    /** The colorSensor field will contain a reference to our color sensor hardware object */\n    NormalizedColorSensor colorSensor;\n    HardwareMap hardwareMap;\n    boolean weShouldRead, weveInitiated;\n    int colorReturned;\n    Thread updateLoopThread;\n    float[] hsvValues = new float[3];\n    public int runCount = 0;\n\n    public ColorSensor(NormalizedColorSensor sensor) {\n        //   this.hardwareMap = _hardwareMap; //since we don't get the hardwaremap by default-- this isn't an OpMode-- we have to set it manually\n        this.weveInitiated = true; //We have initiated the code\n        this.colorReturned = 0;\n        this.weShouldRead = true;\n        this.colorSensor = sensor;\n        //hardwareMap.get(NormalizedColorSensor.class, \"sensor\"); // set the colorSensor to the actual hardware color sensor\n        // this.runSample(); // actually execute the sampling code; start up the loop\n    }\n    public ColorSensor(HardwareMap _hardwareMap) {\n        this.hardwareMap = _hardwareMap; //since we don't get the hardwaremap by default-- this isn't an OpMode-- we have to set it manually\n        this.weveInitiated = true; //We have initiated the code\n        this.colorReturned = 0;\n        this.weShouldRead = false;\n        this.colorSensor = hardwareMap.get(NormalizedColorSensor.class, \"sensor\"); // set the colorSensor to the actual hardware color sensor\n        // this.runSample(); // actually execute the sampling code; start up the loop\n    }\n\n    public void startAsyncLoop() {\n        updateLoopThread = new Thread(new UpdateLoopThread());\n        updateLoopThread.start();\n    }\n\n    //Switch the sample loop on/off\n    public void switchSampling(boolean start_or_dont) {\n        //save a boolean for the loop's state before changes\n        boolean weShouldReadold = this.weShouldRead;\n        this.weShouldRead = start_or_dont;\n        //if it's switching on from being previously off, start the loop again\n    }\n\n    //return our color integer\n    public int getColorInt () {\n        return this.colorReturned;\n    }\n\n    public String getHexCode() {\n        return Color.red(this.colorReturned) + \" | \"+ Color.green(this.colorReturned) + \" | \" + Color.blue(this.colorReturned) + \" | \" +Color.alpha(this.colorReturned);\n    }\n\n    public float[] getHsv() {\n        return this.hsvValues;\n    }\n\n  \n\n    public boolean getReadState() {\n\n        return this.weShouldRead;\n       // Color.alpha(this.colorReturned);\n    }\n    public int getAlpha(){\n       return Color.alpha(this.colorReturned);\n    }\n\n    public boolean isSpecial1() {\n        return Color.alpha(this.colorReturned) >= 200;\n\n    }\n\n    //Test if we're seeing gold\n    public boolean isSpecial2() {\n        return PaulMath.delta(46 / 360, hsvValues[0]) < 0.075f && PaulMath.delta(0.27f, hsvValues[1]) < 0.075f && PaulMath.delta(0.23f, hsvValues[2]) < 0.075f;\n    }\n\n    public void runSample() {\n\n        this.runCount++;\n\n\n        // If possible, turn the light on in the beginning (it might already be on anyway,\n        // we just make sure it is if we can).\n        if (this.colorSensor instanceof SwitchableLight) {\n            ((SwitchableLight)this.colorSensor).enableLight(true);\n        }\n\n        // Loop until we are asked to stop\n        // Read the sensor\n        NormalizedRGBA colors = this.colorSensor.getNormalizedColors();\n\n        //Convert the color to HSV\n        Color.colorToHSV(colors.toColor(), this.hsvValues);\n\n        //normalize the colors-- make it so brightness won't affect our readout (much)\n        float max = Math.max(Math.max(colors.red, colors.green), Math.max(colors.blue, colors.alpha));\n        colors.red /= max;\n        colors.green /= max;\n        colors.blue /= max;\n\n\n        //set the colorReturned variable so it can be used by the other methods\n        this.colorReturned = colors.toColor();\n    }\n\n    public class UpdateLoopThread implements Runnable {\n        @Override\n        public void run() {\n            while(weShouldRead) {\n                runSample();\n            }\n        }\n\n\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java	(revision df0551598334b89f16e4e7a0a005269f3de6ed08)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java	(date 1614463331000)
@@ -66,7 +66,7 @@
         return this.hsvValues;
     }
 
-  
+
 
     public boolean getReadState() {
 
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/SwitchAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.autonomous;\n\nimport com.qualcomm.robotcore.eventloop.opmode.Autonomous;\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.hardware.CRServo;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\nimport com.qualcomm.robotcore.hardware.Servo;\n\nimport org.firstinspires.ftc.teamcode.auxilary.AutoState;\nimport org.firstinspires.ftc.teamcode.auxilary.ColorSensor;\nimport org.firstinspires.ftc.teamcode.auxilary.PaulMath;\nimport org.firstinspires.ftc.teamcode.auxilary.StateMachine;\nimport org.firstinspires.ftc.teamcode.managers.ImuManager;\nimport org.firstinspires.ftc.teamcode.managers.ManipulationManager;\nimport org.firstinspires.ftc.teamcode.managers.MovementManager;\n\n@Autonomous\npublic class SwitchAuto extends OpMode {\n\n    MovementManager driver;\n    ManipulationManager limbs;\n    ColorSensor sensorOne;\n    ColorSensor sensorFour;\n    ImuManager imu;\n    int step;\n    int conditional;\n    double startTime;\n\n    public void init() {\n        resetStartTime();\n        driver = new MovementManager(hardwareMap.get(DcMotor.class, \"fl\"),\n                hardwareMap.get(DcMotor.class, \"fr\"),\n                hardwareMap.get(DcMotor.class, \"bl\"),\n                hardwareMap.get(DcMotor.class, \"br\"));\n        limbs = new ManipulationManager(\n                new CRServo[] {\n                        hardwareMap.get(CRServo.class, \"shooterArm\")\n                },\n                new String[] {\n                        \"shooterArm\"\n                },\n                new Servo[] {},\n                new String[] {},\n                new DcMotor[] {\n                        hardwareMap.get(DcMotor.class, \"drum\"),\n                        hardwareMap.get(DcMotor.class, \"intake\"),\n                        hardwareMap.get(DcMotor.class, \"flywheelRight\"),\n                        hardwareMap.get(DcMotor.class, \"flywheelLeft\")\n                },\n                new String[] {\n                        \"drum\",\n                        \"intake\",\n                        \"flywheelRight\",\n                        \"flywheelLeft\"\n                }\n        );\n        imu = new ImuManager(hardwareMap.get(com.qualcomm.hardware.bosch.BNO055IMU.class, \"imu\"));\n        sensorOne = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, \"sensorOne\"));\n        sensorFour = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, \"sensorFour\"));\n\n\n\n        /*\n            ... init limbs and driver, not shown ...\n         */\n        step = 0;\n    }\n\n\n    public void loop() {\n\n\n        switch(step){\n            case 0:\n                //set shooterArm and turn on Flywheels\n                limbs.setServoPower(\"shooterArm\", 0.63);\n                limbs.setMotorPower(\"flywheelRight\", -1);\n                limbs.setMotorPower(\"flywheelLeft\", 1);\n                step++;\n                startTime = getRuntime(); break;\n            case 1:\n                //go forward\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw( 0.6f, 0.6f, 0.6f, 0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 2:\n                //strafe to rings\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw(0.4f,-0.4f,-0.4f, 0.4f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 3:\n                //scan and set conditional\n                sensorOne.runSample();\n                sensorFour.runSample();\n                if(sensorOne.isSpecial1()) {\n                    if(sensorFour.isSpecial1()){\n                        conditional = 4;\n                    } else conditional = 1;\n                } else conditional = 0;\n                step++;\n                startTime = getRuntime(); break;\n            case 4:\n                //strafe back to center\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw(-0.4f,0.4f,0.4f, -0.4f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 5:\n                //drive to line\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 6:\n                //shoot ring 1\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 7:\n                //retract\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0.63);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 8:\n                //shoot ring 2\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 9:\n                //retract\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0.63);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 10:\n                //shoot ring 3\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 11:\n                //retract\n                if(getRuntime()-startTime < .5) {\n                    limbs.setServoPower(\"shooterArm\", 0.63);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 12:\n                //Choose one of three paths based on conditional. 20 = 0 rings, 30 = 1 ring, 40 = 4 rings\n                if(conditional == 0) {step = 20; startTime = getRuntime(); break;}\n                    else if (conditional == 1) {step = 30; startTime = getRuntime(); break;}\n                    else if (conditional == 4) {step = 40; startTime = getRuntime(); break;}\n            case 20:\n                //If 0 rings go forward\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 21:\n                //lower wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleArmLeft\", 1);\n//                    limbs.setServoPower(\"wobleArmRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 22:\n                //release wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleClawLeft\", 1);\n//                    limbs.setServoPower(\"wobleClawRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 23:\n                //go back to line and park\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw(-0.6f, -0.6f, 0.6f, 0.6f);\n                } else {\n                    driver.stopDrive();\n                    step = 77;\n                    startTime = getRuntime(); break;\n                }\n            case 30:\n                //If 1 ring drive forward more\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 31:\n                //strafe to section 1\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw(-0.4f,0.4f,0.4f, -0.4f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 32:\n                //lower wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleArmLeft\", 1);\n//                    limbs.setServoPower(\"wobleArmRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 33:\n                //release wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleClawLeft\", 1);\n//                    limbs.setServoPower(\"wobleClawRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 34:\n                //drive back to line and park\n                if(getRuntime()-startTime < 1) {\n                    driver.driveRaw(-0.6f, -0.6f, 0.6f, 0.6f);\n                } else {\n                    driver.stopDrive();\n                    step = 77;\n                    startTime = getRuntime(); break;\n                }\n            case 40:\n                if(getRuntime()-startTime < 1.5) {\n                    driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 41:\n                //If 4 rings drive to thirds section\n                if(getRuntime()-startTime < 1.5) {\n                    driver.driveRaw(0.6f,0.6f,-0.6f, -0.6f);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 42:\n                //turn 90 degrees\n                if(getRuntime()-startTime < 1) {\n                    imu.getPosition();\n                    float proportional = PaulMath.proportionalPID(imu.getOrientation().thirdAngle, -90);\n                    driver.driveRaw(-proportional, proportional, -proportional, proportional);\n                } else {\n                    driver.stopDrive();\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 43:\n                //lower wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleArmLeft\", 1);\n//                    limbs.setServoPower(\"wobleArmRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 44:\n                //release wobble goal\n                if(getRuntime()-startTime < .5) {\n//                    limbs.setServoPower(\"wobleClawLeft\", 1);\n//                    limbs.setServoPower(\"wobleClawRight\", -1);\n                } else {\n                    step++;\n                    startTime = getRuntime(); break;\n                }\n            case 45:\n                //drive back to the line and park\n                if(getRuntime()-startTime < 1.5) {\n                    driver.driveRaw(-0.6f,-0.6f,0.6f, 0.6f);\n                } else {\n                    driver.stopDrive();\n                    step = 77;\n                    startTime = getRuntime(); break;\n                }\n        }\n\n        telemetry.addData(\"Step:\", step);\n        telemetry.addData(\"IMU Orientation: \", imu.getOrientation().thirdAngle);\n        telemetry.addData(\"IMU Acceleration: \", imu.getLinearAcceleration().toString());\n        telemetry.addData(\"IMU Position: \", imu.getPosition().toString());\n        telemetry.addData(\"Time:\", getRuntime());\n        telemetry.addData(\"StartTime: \", startTime);\n        telemetry.addData(\"Step Run Time:\", getRuntime()-startTime);\n        telemetry.addData(\"Drum Power\", limbs.getMotorPower(\"drum\"));\n        telemetry.addData(\"Intake Power\", limbs.getMotorPower(\"intake\"));\n        telemetry.addData(\"Flywheel Right Power\", limbs.getMotorPower(\"flywheelRight\"));\n        telemetry.addData(\"Flywheel Left Power\", limbs.getMotorPower(\"flywheelLeft\"));\n        telemetry.addData(\"FL Power: \", driver.frontLeft.getPower());\n        telemetry.addData(\"FR Power: \", driver.frontRight.getPower());\n        telemetry.addData(\"BL Power: \", driver.backLeft.getPower());\n        telemetry.addData(\"BR Power: \", driver.backRight.getPower());\n\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/SwitchAuto.java	(revision df0551598334b89f16e4e7a0a005269f3de6ed08)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/SwitchAuto.java	(date 1614463280000)
@@ -6,6 +6,7 @@
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.NormalizedColorSensor;
 import com.qualcomm.robotcore.hardware.Servo;
+import com.qualcomm.robotcore.util.ElapsedTime;
 
 import org.firstinspires.ftc.teamcode.auxilary.AutoState;
 import org.firstinspires.ftc.teamcode.auxilary.ColorSensor;
@@ -67,10 +68,8 @@
         step = 0;
     }
 
-
     public void loop() {
 
-
         switch(step){
             case 0:
                 //set shooterArm and turn on Flywheels
@@ -84,7 +83,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw( 0.6f, 0.6f, 0.6f, 0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -93,7 +92,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw(0.4f,-0.4f,-0.4f, 0.4f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -113,7 +112,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw(-0.4f,0.4f,0.4f, -0.4f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -122,7 +121,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -184,7 +183,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -211,7 +210,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw(-0.6f, -0.6f, 0.6f, 0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step = 77;
                     startTime = getRuntime(); break;
                 }
@@ -220,7 +219,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -229,7 +228,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw(-0.4f,0.4f,0.4f, -0.4f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -256,7 +255,7 @@
                 if(getRuntime()-startTime < 1) {
                     driver.driveRaw(-0.6f, -0.6f, 0.6f, 0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step = 77;
                     startTime = getRuntime(); break;
                 }
@@ -264,7 +263,7 @@
                 if(getRuntime()-startTime < 1.5) {
                     driver.driveRaw( 0.6f, 0.6f, -0.6f, -0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -273,7 +272,7 @@
                 if(getRuntime()-startTime < 1.5) {
                     driver.driveRaw(0.6f,0.6f,-0.6f, -0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -284,7 +283,7 @@
                     float proportional = PaulMath.proportionalPID(imu.getOrientation().thirdAngle, -90);
                     driver.driveRaw(-proportional, proportional, -proportional, proportional);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step++;
                     startTime = getRuntime(); break;
                 }
@@ -311,7 +310,7 @@
                 if(getRuntime()-startTime < 1.5) {
                     driver.driveRaw(-0.6f,-0.6f,0.6f, 0.6f);
                 } else {
-                    driver.stopDrive();
+                    driver.driveRaw(0f, 0f, 0f, 0f);
                     step = 77;
                     startTime = getRuntime(); break;
                 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/StepAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/StepAuto.java	(date 1614463280000)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/StepAuto.java	(date 1614463280000)
@@ -0,0 +1,70 @@
+package org.firstinspires.ftc.teamcode.autonomous;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+enum step {
+    START, MOVE1, MOVE2, MOVE3, MOVE4, MOVE5, MOVE6, MOVE7, MOVE8, MOVE9, MOVE10, MOVE11, MOVE12, MOVE13, MOVE14, MOVE15, MOVE16, MOVE17, MOVE18, MOVE19, MOVE20, MOVE21, MOVE22, MOVE23, MOVE24, MOVE25, MOVE26, MOVE27, MOVE28, MOVE29, MOVE30, MOVE31, MOVE32,
+    THREADONE1, THREADONE2, THREADONE3, THREADONE4, THREADONE5, THREADONE6, THREADONE7,
+    THREADTWO1, THREADTWO2, THREADTWO3, THREADTWO4, THREADTWO5, THREADTWO6, THREADTWO7,
+    THREADTHREE1, THREADTHREE2, THREADTHREE3, THREADTHREE4, THREADTHREE5, THREADTHREE6, THREADTHREE7;
+}
+
+@Autonomous
+public class StepAuto extends OpMode {
+    ElapsedTime timer;
+    step currentStep = step.START;
+
+    int numberCalled = 0;
+    double referPoint = 0;
+
+    public step getNext() {
+        step[] x = step.values();
+        int i = 0;
+        for (; x[i] != currentStep; i++);
+        i++;
+        i %= x.length;
+        return x[i];
+    }
+
+    public void init() {
+
+    }
+    public void loop() {
+
+    }
+
+    void nextStep(int milliseconds) {
+        if(timer == null)
+            timer = new ElapsedTime();
+        if(currentStep == null)
+            currentStep = step.START;
+
+
+
+        numberCalled++;
+        if(numberCalled == 1) {
+            referPoint = timer.milliseconds();
+        }
+
+        if (timer.milliseconds() - referPoint >= milliseconds) {
+            numberCalled = 0;
+            currentStep = getNext();
+        }
+    }
+
+    long delayRunTime;
+    boolean delaying;
+    public void wait(int delay, LinearOpMode opmode) {
+
+        if(!delaying) {
+            delaying = true;
+            delayRunTime = System.currentTimeMillis();
+        }
+        while(System.currentTimeMillis() - delayRunTime <= delay && opmode.opModeIsActive()) {}
+
+        delaying = false;
+    }
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/DeltaVFrankenstein.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/DeltaVFrankenstein.java	(date 1614463280000)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/autonomous/DeltaVFrankenstein.java	(date 1614463280000)
@@ -0,0 +1,84 @@
+package org.firstinspires.ftc.teamcode.autonomous;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.eventloop.opmode.OpMode;
+import com.qualcomm.robotcore.hardware.CRServo;
+import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.NormalizedColorSensor;
+import com.qualcomm.robotcore.hardware.Servo;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+import org.firstinspires.ftc.teamcode.managers.*;
+import org.firstinspires.ftc.teamcode.auxilary.*;
+
+import java.util.ArrayList;
+import java.util.Timer;
+
+@Autonomous(group = "Step")
+public class DeltaVFrankenstein extends StepAuto {
+    MovementManager driver;
+    ManipulationManager limbs;
+    ColorSensor sensorOne;
+    ColorSensor sensorFour;
+    ImuManager imu;
+
+
+    public void init() {
+        driver = new MovementManager(hardwareMap.get(DcMotor.class, "fl"),
+                hardwareMap.get(DcMotor.class, "fr"),
+                hardwareMap.get(DcMotor.class, "bl"),
+                hardwareMap.get(DcMotor.class, "br"));
+
+        limbs = new ManipulationManager(
+                new CRServo[] {
+                        hardwareMap.get(CRServo.class, "shooterArm")
+                },
+                new String[] {
+                        "shooterArm"
+                },
+                new Servo[] {},
+                new String[] {},
+                new DcMotor[] {
+                        hardwareMap.get(DcMotor.class, "drum"),
+                        hardwareMap.get(DcMotor.class, "intake"),
+                        hardwareMap.get(DcMotor.class, "flywheelRight"),
+                        hardwareMap.get(DcMotor.class, "flywheelLeft")
+                },
+                new String[] {
+                        "drum",
+                        "intake",
+                        "flywheelRight",
+                        "flywheelLeft"
+                }
+        );
+
+        imu = new ImuManager(hardwareMap.get(com.qualcomm.hardware.bosch.BNO055IMU.class, "imu"));
+        sensorOne = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, "sensorOne"));
+        sensorFour = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, "sensorFour"));
+
+    }
+
+
+
+    public void loop() {
+        switch(currentStep){
+            case START:
+                driver.driveRaw(0f, 0f, 0f, 0f);
+                nextStep(20000);
+                break;
+            case MOVE1:
+                driver.driveRaw(0.5f, 0.5f, -0.5f, -0.5f);
+                nextStep(1000);
+                break;
+
+            default:
+                driver.driveRaw(0f, 0f, 0f, 0f);
+
+        }
+        telemetry.addData("FL Power: ", driver.frontLeft.getPower());
+        telemetry.addData("FR Power: ", driver.frontRight.getPower());
+        telemetry.addData("BL Power: ", driver.backLeft.getPower());
+        telemetry.addData("BR Power: ", driver.backRight.getPower());
+
+    }
+}
