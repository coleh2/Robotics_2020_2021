Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.auxilary;\n\nimport android.graphics.Color;\n\nimport com.qualcomm.robotcore.hardware.HardwareMap;\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\nimport com.qualcomm.robotcore.hardware.NormalizedRGBA;\nimport com.qualcomm.robotcore.hardware.SwitchableLight;\n\nimport org.firstinspires.ftc.teamcode.autonomous.*;\nimport org.firstinspires.ftc.teamcode.auxilary.*;\nimport org.firstinspires.ftc.teamcode.managers.*;\nimport org.firstinspires.ftc.teamcode.teleop.*;\n\npublic class ColorSensor {\n    /** The colorSensor field will contain a reference to our color sensor hardware object */\n    NormalizedColorSensor colorSensor;\n    HardwareMap hardwareMap;\n    boolean weShouldRead, weveInitiated;\n    int colorReturned;\n    Thread updateLoopThread;\n    float[] hsvValues = new float[3];\n\n    public int runCount = 0;\n\n    public ColorSensor(NormalizedColorSensor sensor) {\n        //   this.hardwareMap = _hardwareMap; //since we don't get the hardwaremap by default-- this isn't an OpMode-- we have to set it manually\n        this.weveInitiated = true; //We have initiated the code\n        this.colorReturned = 0;\n        this.weShouldRead = true;\n        this.colorSensor = sensor;\n        //hardwareMap.get(NormalizedColorSensor.class, \"sensor\"); // set the colorSensor to the actual hardware color sensor\n        // this.runSample(); // actually execute the sampling code; start up the loop\n    }\n    public ColorSensor(HardwareMap _hardwareMap) {\n        this.hardwareMap = _hardwareMap; //since we don't get the hardwaremap by default-- this isn't an OpMode-- we have to set it manually\n        this.weveInitiated = true; //We have initiated the code\n        this.colorReturned = 0;\n        this.weShouldRead = false;\n        this.colorSensor = hardwareMap.get(NormalizedColorSensor.class, \"sensor\"); // set the colorSensor to the actual hardware color sensor\n        // this.runSample(); // actually execute the sampling code; start up the loop\n    }\n\n    public void startAsyncLoop() {\n        updateLoopThread = new Thread(new UpdateLoopThread());\n        updateLoopThread.start();\n    }\n\n    //Switch the sample loop on/off\n    public void switchSampling(boolean start_or_dont) {\n        //save a boolean for the loop's state before changes\n        boolean weShouldReadold = this.weShouldRead;\n        this.weShouldRead = start_or_dont;\n        //if it's switching on from being previously off, start the loop again\n    }\n\n    //return our color integer\n    public int getColorInt () {\n        return this.colorReturned;\n    }\n\n    public String getHexCode() {\n        return Color.red(this.colorReturned) + \" | \"+ Color.green(this.colorReturned) + \" | \" + Color.blue(this.colorReturned) + \" | \" +Color.alpha(this.colorReturned);\n    }\n\n    public float[] getHsv() {\n        return this.hsvValues;\n    }\n\n    public boolean getReadState() {\n\n        return this.weShouldRead;\n    }\n\n    public boolean isSpecial1() {\n        return this.hsvValues[1] > 0.65 ;\n\n    }\n\n    //Test if we're seeing gold\n    public boolean isSpecial2() {\n        return PaulMath.delta(46 / 360, hsvValues[0]) < 0.075f && PaulMath.delta(0.27f, hsvValues[1]) < 0.075f && PaulMath.delta(0.23f, hsvValues[2]) < 0.075f;\n    }\n\n    public void runSample() {\n\n        this.runCount++;\n\n\n        // If possible, turn the light on in the beginning (it might already be on anyway,\n        // we just make sure it is if we can).\n        if (this.colorSensor instanceof SwitchableLight) {\n            ((SwitchableLight)this.colorSensor).enableLight(true);\n        }\n\n        // Loop until we are asked to stop\n        // Read the sensor\n        NormalizedRGBA colors = this.colorSensor.getNormalizedColors();\n\n        //Convert the color to HSV\n        Color.colorToHSV(colors.toColor(), this.hsvValues);\n\n        //normalize the colors-- make it so brightness won't affect our readout (much)\n        float max = Math.max(Math.max(colors.red, colors.green), Math.max(colors.blue, colors.alpha));\n        colors.red /= max;\n        colors.green /= max;\n        colors.blue /= max;\n\n\n        //set the colorReturned variable so it can be used by the other methods\n        this.colorReturned = colors.toColor();\n    }\n\n    public class UpdateLoopThread implements Runnable {\n        @Override\n        public void run() {\n            while(weShouldRead) {\n                runSample();\n            }\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java	(revision 587596af7857cadee080d14233b1a94e1e4b327f)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/auxilary/ColorSensor.java	(date 1614457652000)
@@ -20,7 +20,6 @@
     int colorReturned;
     Thread updateLoopThread;
     float[] hsvValues = new float[3];
-
     public int runCount = 0;
 
     public ColorSensor(NormalizedColorSensor sensor) {
@@ -73,7 +72,7 @@
     }
 
     public boolean isSpecial1() {
-        return this.hsvValues[1] > 0.65 ;
+        return this.hsvValues(0)   ;
 
     }
 
@@ -118,5 +117,7 @@
                 runSample();
             }
         }
+
+
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/testOpmodes/TeleopColorSensor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.testOpmodes;\n\nimport com.qualcomm.robotcore.eventloop.opmode.OpMode;\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\nimport com.qualcomm.robotcore.hardware.CRServo;\nimport com.qualcomm.robotcore.hardware.DcMotor;\nimport com.qualcomm.robotcore.hardware.NormalizedColorSensor;\nimport com.qualcomm.robotcore.hardware.Servo;\n\nimport org.firstinspires.ftc.teamcode.auxilary.controlmaps.ShootingTogglesControlMap;\nimport org.firstinspires.ftc.teamcode.auxilary.ColorSensor;\nimport org.firstinspires.ftc.teamcode.managers.FeatureManager;\nimport org.firstinspires.ftc.teamcode.managers.ImuManager;\nimport org.firstinspires.ftc.teamcode.managers.InputManager;\nimport org.firstinspires.ftc.teamcode.managers.ManipulationManager;\nimport org.firstinspires.ftc.teamcode.managers.MovementManager;\n\n\n@TeleOp\npublic class TeleopColorSensor extends OpMode {\n\n    InputManager input;\n    MovementManager driver;\n    ManipulationManager limbs;\n    ColorSensor sensorOne;\n    ColorSensor sensorFour;\n    Servo grab;\n    ImuManager imu;\n\n    private static boolean toggleSpeed = false;\n\n    public void init() {\n        FeatureManager.logger.setBackend(telemetry.log());\n\n        driver = new MovementManager(hardwareMap.get(DcMotor.class, \"fl\"),\n                hardwareMap.get(DcMotor.class, \"fr\"),\n                hardwareMap.get(DcMotor.class, \"br\"),\n                hardwareMap.get(DcMotor.class, \"bl\"));\n        input = new InputManager(gamepad1, new ShootingTogglesControlMap());\n        imu = new ImuManager(hardwareMap.get(com.qualcomm.hardware.bosch.BNO055IMU.class, \"imu\"));\n        limbs = new ManipulationManager(\n                new CRServo[] {\n                        hardwareMap.get(CRServo.class, \"shooterArm\"),\n                        hardwareMap.get(CRServo.class, \"wobbleArmLeft\"),\n                        hardwareMap.get(CRServo.class, \"wobbleArmRight\"),\n                        hardwareMap.get(CRServo.class, \"wobbleGrabLeft\"),\n                        hardwareMap.get(CRServo.class, \"wobbleGrabRight\")\n                },\n                new String[] {\n                        \"shooterArm\",\n                        \"wobbleArmLeft\",\n                        \"wobbleArmRight\",\n                        \"wobbleGrabLeft\",\n                        \"wobbleGrabRight\"\n                },\n                new Servo[] {\n\n\n                },\n                new String[] {\n\n                },\n                new DcMotor[] {\n                        hardwareMap.get(DcMotor.class, \"drum\"),\n                        hardwareMap.get(DcMotor.class, \"intake\"),\n                        hardwareMap.get(DcMotor.class, \"flywheelRight\"),\n                        hardwareMap.get(DcMotor.class, \"flywheelLeft\")\n                },\n                new String[] {\n                        \"drum\",\n                        \"intake\",\n                        \"flywheelRight\",\n                        \"flywheelLeft\"\n                }\n        );\n\n        driver.resetEncoders();\n        driver.runUsingEncoders();\n\n        sensorOne = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, \"sensorOne\"));\n        sensorFour = new ColorSensor(hardwareMap.get(NormalizedColorSensor.class, \"sensorFour\"));\n    }\n\n    public void loop() {\n        input.update();\n\n        driver.driveOmni((input.getVector(\"drive\")));\n\n        limbs.setMotorPower(\"intake\", 0.5*input.getScalar(\"fullIntake\"));\n        limbs.setServoPower(\"wobbleArmRight\", input.getScalar(\"wobbleGraber\"));\n        limbs.setServoPower(\"wobbleGrabRight\", input.getScalar(\"wobbleGraberNegative\"));\n        limbs.setServoPower(\"wobbleArmLeft\", -input.getScalar(\"wobbleGraber\"));\n        limbs.setServoPower(\"wobbleGrabLeft\", -input.getScalar(\"wobbleGraberNegative\"));\n\n        sensorOne.runSample();\n        sensorFour.runSample();\n\n        if(input.getGamepad().right_trigger > 0.1) {\n            limbs.setMotorPower(\"flywheelRight\", -1);\n            limbs.setMotorPower(\"flywheelLeft\", 1);\n        } else {\n            limbs.setMotorPower(\"flywheelRight\", 0);\n            limbs.setMotorPower(\"flywheelLeft\", 0);\n        }\n\n        if(input.getGamepad().a) {\n            limbs.setServoPower(\"shooterArm\", 0.325);\n        } else {\n            limbs.setServoPower(\"shooterArm\", 0.65);\n        }\n\n        limbs.setMotorPower(\"drum\", (input.getGamepad().right_trigger > 0.1 || input.getScalar(\"fullIntake\") == 1) ? -1 : 0);\n\n        if(input.getGamepad().dpad_up) {\n            limbs.setMotorPower(\"drum\", -1);\n        } else if(input.getGamepad().dpad_down) {\n            limbs.setMotorPower(\"drum\", 1);\n        }\n\n\n\n//        telemetry.addData(\"FL Ticks:\", driver.frontLeft.getCurrentPosition());\n//        telemetry.addData(\"FR Ticks:\", driver.frontRight.getCurrentPosition());\n//        telemetry.addData(\"BL Ticks:\", driver.backRight.getCurrentPosition());\n//        telemetry.addData(\"BR Ticks:\", driver.backLeft.getCurrentPosition());\n//        telemetry.addData(\"Average Ticks:\", (driver.frontLeft.getCurrentPosition()+\n//                driver.frontRight.getCurrentPosition()+\n//                driver.backLeft.getCurrentPosition()+\n//                driver.backRight.getCurrentPosition())/4);\n\n        telemetry.addData(\"colorhsv_one\",sensorOne.getHsv()[0] + \",\" + sensorOne.getHsv()[1] + \",\" + sensorOne.getHsv()[2]);\n        telemetry.addData(\"colorhsv_four\",sensorFour.getHsv()[0] + \",\" + sensorFour.getHsv()[1] + \",\" + sensorFour.getHsv()[2]);\n        telemetry.addData(\"Color Code\", sensorOne.getHexCode());\n        telemetry.addData(\"Color Code\", sensorFour.getHexCode());\n\n        telemetry.addData(\"FL Power: \", driver.frontLeft.getPower());\n        telemetry.addData(\"FL Port: \", driver.frontLeft.getPortNumber());\n\n        telemetry.addData(\"FR Power: \", driver.frontRight.getPower());\n        telemetry.addData(\"FR Port: \", driver.frontRight.getPortNumber());\n\n        telemetry.addData(\"BL Power: \", driver.backLeft.getPower());\n        telemetry.addData(\"BL Port: \", driver.backLeft.getPortNumber());\n\n        telemetry.addData(\"BR Power: \", driver.backRight.getPower());\n        telemetry.addData(\"BR Port: \", driver.backRight.getPortNumber());\n\n        telemetry.addData(\"Drum Power\", limbs.getMotorPower(\"drum\"));\n        telemetry.addData(\"Intake Power\", limbs.getMotorPower(\"intake\"));\n        telemetry.addData(\"Flywheel Right Power\", limbs.getMotorPower(\"flywheelRight\"));\n        telemetry.addData(\"Flywheel Left Power\", limbs.getMotorPower(\"flywheelLeft\"));\n        telemetry.addData(\"Orientation\", imu.getOrientation().toString());\n\n        telemetry.addData(\"speed: \", driver.getScale());\n\n        telemetry.addData(\"left trigger: \", input.getGamepad().left_trigger);\n\n        telemetry.addData(\"controls://fullIntake:\", input.getControl(\"fullIntake\").toString());\n        telemetry.addData(\"controls://lt:\", input.getScalar(\"lt\"));\n\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/testOpmodes/TeleopColorSensor.java	(revision 587596af7857cadee080d14233b1a94e1e4b327f)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/testOpmodes/TeleopColorSensor.java	(date 1614457652000)
@@ -27,7 +27,9 @@
     Servo grab;
     ImuManager imu;
 
+
     private static boolean toggleSpeed = false;
+  //  private Object;
 
     public void init() {
         FeatureManager.logger.setBackend(telemetry.log());
@@ -86,15 +88,22 @@
 
         driver.driveOmni((input.getVector("drive")));
 
-        limbs.setMotorPower("intake", 0.5*input.getScalar("fullIntake"));
-        limbs.setServoPower("wobbleArmRight", input.getScalar("wobbleGraber"));
-        limbs.setServoPower("wobbleGrabRight", input.getScalar("wobbleGraberNegative"));
-        limbs.setServoPower("wobbleArmLeft", -input.getScalar("wobbleGraber"));
-        limbs.setServoPower("wobbleGrabLeft", -input.getScalar("wobbleGraberNegative"));
+//        limbs.setMotorPower("intake", 0.5*input.getScalar("fullIntake"));
+//        limbs.setServoPower("wobbleArmRight", input.getScalar("wobbleGraber"));
+//        limbs.setServoPower("wobbleGrabRight", input.getScalar("wobbleGraberNegative"));
+//        limbs.setServoPower("wobbleArmLeft", -input.getScalar("wobbleGraber"));
+//        limbs.setServoPower("wobbleGrabLeft", -input.getScalar("wobbleGraberNegative"));
 
         sensorOne.runSample();
         sensorFour.runSample();
 
+        public boolean isSpecial1() {
+            return this.hsvValues(0)   ;
+
+        }
+
+
+
         if(input.getGamepad().right_trigger > 0.1) {
             limbs.setMotorPower("flywheelRight", -1);
             limbs.setMotorPower("flywheelLeft", 1);
@@ -128,8 +137,15 @@
 //                driver.backLeft.getCurrentPosition()+
 //                driver.backRight.getCurrentPosition())/4);
 
-        telemetry.addData("colorhsv_one",sensorOne.getHsv()[0] + "," + sensorOne.getHsv()[1] + "," + sensorOne.getHsv()[2]);
-        telemetry.addData("colorhsv_four",sensorFour.getHsv()[0] + "," + sensorFour.getHsv()[1] + "," + sensorFour.getHsv()[2]);
+        telemetry.addData("colorhsv_oneHue",sensorOne.getHsv()[0]);
+        telemetry.addData("colorhsv_SAT",sensorOne.getHsv()[1]);
+        telemetry.addData("colorhsv_VALUE", sensorOne.getHsv()[2]);
+
+        telemetry.addData("colorhsv_fourHUE",sensorOne.getHsv()[0]);
+        telemetry.addData("colorhsv_SAT",sensorOne.getHsv()[1]);
+        telemetry.addData("colorhsv_VALUE", sensorOne.getHsv()[2]);
+
+
         telemetry.addData("Color Code", sensorOne.getHexCode());
         telemetry.addData("Color Code", sensorFour.getHexCode());
 
