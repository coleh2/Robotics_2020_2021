<!DOCTYPE html>
<html>

<head>
    <title>Dashboard</title>
    <meta charset="utf-8">
    <script>
        var mouseX = 0, mouseY = 0, gridSize = Math.max(window.innerHeight, window.innerWidth) / 16, widgetsParent = undefined;

        var widgetsReg = {};

        var fields = [];

        var widgetTypes = {
            "none": {
                init: function (parent) { parent.innerHTML = ""; },
                ondata: function (data, parent) { }
            },
            "meta.theme": {
                init: function (parent) {
                    var select = document.createElement("select");
                    var themes = ["dark", "light"];
                    var current = localStorage.getItem("theme");

                    for (var i = 0; i < themes.length; i++) {
                        var opt = document.createElement("option");
                        if (themes[i] == current) opt.selected = true;
                        opt.textContent = themes[i];
                        select.appendChild(opt);
                    }

                    select.addEventListener("change", function () {
                        localStorage.setItem("theme", themes[select.selectedIndex]);
                        document.body.classList.remove("dark-theme");
                        document.body.classList.remove("light-theme");
                        document.body.classList.add(themes[select.selectedIndex] + "-theme");
                    });

                    parent.appendChild(select);
                },
                ondata: function (data, parent) { }
            },
            "debug.alldata": {
                init: function (parent, state) {
                    var pre = document.createElement("pre");
                    state.pre = pre;
                    parent.appendChild(pre);
                },
                ondata: function (data, parent, state) {
                    var scrolledToBottom = parent.scrollHeight - Math.abs(parent.scrollTop) === parent.clientHeight;

                    //override for when the scroll changes on hover
                    if (state.lastScrolledToBottom && state.lastScroll == parent.scrollTop) scrolledToBottom = true;

                    state.pre.appendChild(document.createTextNode(JSON.stringify(data) + "\n"));

                    if (scrolledToBottom) parent.scrollTop = parent.scrollHeight - parent.clientHeight;

                    state.lastScroll = parent.scrollTop;
                    state.lastScrolledToBottom = scrolledToBottom;
                }
            },
            "chart.bar": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "chart.line": {
                init: function (parent, state, config, box) {
                    //use object.assign to avoid mutation of original box
                    state.box = {};
                    Object.assign(state.box, box);

                    state.datapoints = [];

                    var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.classList.add("widget--line-chart");

                    svg.setAttribute("height", box.height * gridSize);
                    svg.setAttribute("width", box.width * gridSize);

                    //scale up for a crisper view
                    state.box.height *= 2 * gridSize;
                    state.box.width *= 2 * gridSize;

                    svg.setAttribute("viewBox", `0 0 ${state.box.width} ${state.box.height}`);
                    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
                    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");

                    var path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    path.classList.add("widget--line-chart--stroke-line");

                    var fillPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
                    fillPath.classList.add("widget--line-chart--fill-line");

                    //caption lines
                    for (var i = 0; i <= 4; i++) {
                        var captionLine = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        captionLine.classList.add("widget--line-chart--caption-line");
                        captionLine.setAttribute("d", "M0," + (state.box.height * i / 4) + "H" + state.box.width);
                        svg.appendChild(captionLine);
                    }

                    state.captions = [];
                    //captions themselves. They go after so that they'll overlay the lines.
                    for (var i = 0; i <= 4; i++) {
                        //use IEFE so that `i` is preserved in each
                        (function (i) {
                            var caption = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            caption.classList.add("widget--line-chart--caption");
                            caption.setAttribute("x", 0);
                            caption.setAttribute("y", (state.box.height * i / 4) - 6);


                            state.captions.push(function (max) {
                                caption.textContent = (max * (1 - i / 4)).toString().substring(0, 5);
                            });

                            svg.appendChild(caption);
                        })(i);
                    }

                    svg.appendChild(fillPath);
                    svg.appendChild(path);


                    state.path = path;
                    state.fill = fillPath;

                    parent.appendChild(svg);
                    parent.classList.add("nopadding");
                    parent.classList.add("nooverflow");
                },
                ondata: function (data, parent, state, config) {
                    state.datapoints.push({
                        x: Date.now(),
                        y: data.fields[config.field]
                    });

                    var line = drawLine(state.datapoints, state.box, config.xScaleSeconds * 1000);

                    var max = state.datapoints[0].y;
                    for (var i = 0; i < state.datapoints.length; i++) max = Math.max(max, state.datapoints[i].y);

                    max = Math.round(max * 1000) / 1000;

                    for (var i = 0; i < state.captions.length; i++) {
                        state.captions[i](max);
                    }

                    state.path.setAttribute("d", line);
                    state.fill.setAttribute("d", line + "L" + state.box.width + "," + state.box.height + "L" + (0) + "," + (state.box.height) + "Z");
                },
                config: [
                    {
                        name: "field",
                        type: "select",
                        value: "field"
                    },
                    {
                        name: "xScaleSeconds",
                        type: "number",
                        default: 5
                    }
                ]
            },
            "chart.pie": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "number.single": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "number.change": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "string.singleline": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "string.long": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "log.autoscroll": {
                init: function (parent, state) {
                    var pre = document.createElement("pre");
                    state.pre = pre;
                    parent.appendChild(pre);
                },
                ondata: function (data, parent, state) {
                    var scrolledToBottom = parent.scrollHeight - Math.abs(parent.scrollTop) === parent.clientHeight;

                    //override for when the scroll changes on hover
                    if (state.lastScrolledToBottom && state.lastScroll == parent.scrollTop) scrolledToBottom = true;

                    state.pre.appendChild(document.createTextNode(data.log + "\n"));

                    if (scrolledToBottom) parent.scrollTop = parent.scrollHeight - parent.clientHeight;

                    state.lastScroll = parent.scrollTop;
                    state.lastScrolledToBottom = scrolledToBottom;
                }
            },
            "log.noautoscroll": {
                init: function (parent, state) {
                    var pre = document.createElement("pre");
                    state.pre = pre;
                    parent.appendChild(pre);
                },
                ondata: function (data, parent, state) {
                    state.pre.appendChild(document.createTextNode(data.log + "\n"));
                }
            },
            "connection.serverlagtime": {
                init: function (parent, state) {
                    state.num = document.createElement("h3");
                    var deltaParent = document.createElement("span");

                    state.deltaIcon = document.createElement("span");
                    state.delta = document.createElement("span");

                    deltaParent.appendChild(state.deltaIcon);
                    deltaParent.appendChild(state.delta);

                    parent.appendChild(state.num);
                    parent.appendChild(deltaParent);
                },
                ondata: function (data, parent, state) {
                    var connectionLag = Date.now() - data.time;

                    if (state.lastConnectionLag === undefined) state.lastConnectionLag = connectionLag;

                    state.num.textContent = connectionLag + "ms";

                    var deltaLag = ((connectionLag - state.lastConnectionLag) / state.lastConnectionLag) * 100;
                    if (deltaLag > 0) state.deltaIcon.textContent = "+";
                    else state.deltaIcon.textContent = "";
                    state.delta.textContent = Math.round(deltaLag) + "%";

                    state.lastConnectionLag = connectionLag;
                }
            },
            "robot.motors": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "robot.motor": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "sensor.color": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "autoauto.stategraph": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "autoauto.variables": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "autoauto.currentstate": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "input.gamepad1": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            },
            "input.gamepad2": {
                init: function (parent) { },
                ondata: function (data, parent) { }
            }
        }

        window.addEventListener("load", function () {

            document.body.style.setProperty("--grid-size", gridSize + "px");

            var boxTotal = Math.ceil((window.innerWidth / gridSize) * (window.innerHeight / gridSize));

            var draggedWidget = undefined;

            var gridBackground = document.getElementById("grid-background");

            widgetsParent = document.getElementById("grid-widgets");

            for (var i = 0; i < boxTotal; i++) {
                gridBackground.appendChild(document.createElement("span"))
            }

            document.addEventListener("dragstart", function (e) {
                e.preventDefault();
            });

            var downX, downY, dragging, dragShadow;
            document.addEventListener("mousedown", function (event) {
                if (draggedWidget == undefined) {
                    downX = mouseX, downY = mouseY;
                    dragging = true;
                }
            });
            document.addEventListener("mousemove", function (event) {
                if (dragging) {
                    event.preventDefault();
                    if (!dragShadow) dragShadow = makeDragShadow();

                    var x = Math.min(mouseX, downX) + 1;
                    var y = Math.min(mouseY, downY) + 1;
                    var width = Math.max(Math.abs(mouseX - downX) + 1, 0);
                    var height = Math.max(Math.abs(mouseY - downY) + 1, 0);

                    dragShadow.style.gridColumn = (x) + " / " + (x + width);
                    dragShadow.style.gridRow = (y) + " / " + (y + height);
                }
            });
            document.addEventListener("mouseup", function () {
                if (dragShadow && dragShadow.parentElement) {
                    dragShadow.parentElement.removeChild(dragShadow);
                    dragShadow = undefined;
                }
                if (dragging) {
                    var x = Math.min(mouseX, downX) + 1;
                    var y = Math.min(mouseY, downY) + 1;
                    var width = Math.max(Math.abs(mouseX - downX) + 1, 0);
                    var height = Math.max(Math.abs(mouseY - downY) + 1, 0);

                    createWidget(x, y, width, height);
                }
                dragging = false;
                draggedWidget = undefined;
            });

            startDataRequest();
        });

        window.addEventListener("mousemove", function (event) {
            mouseX = Math.floor((event.clientX) / gridSize);
            mouseY = Math.floor(event.clientY / gridSize);
        });

        function createWidget(x, y, width, height) {
            var id = widgetsReg.__counter || 0;
            widgetsReg.__counter = id + 1;

            var widget = document.createElement("div");
            widget.classList.add("widget");

            widget.style.gridColumn = (x) + " / " + (x + width);
            widget.style.gridRow = (y) + " / " + (y + height);

            var widgetInner = document.createElement("div");
            widgetInner.classList.add("widget--inner");

            var selfWidget = {
                id: id,
                widget: widget,
                widgetInner: widgetInner,
                toolbar: createWidgetToolbar(id, widgetInner),
                content: createWidgetContent(id, widgetInner),
                type: "none",
                box: {
                    x: x,
                    y: y,
                    height: height,
                    width: width
                }
            };

            widgetsReg[id] = selfWidget;

            (function dragging() {
                var pointerEvents = ["click", "dblclick", "mousedown"];

                for (var i = 0; i < pointerEvents.length; i++) {
                    widget.addEventListener(pointerEvents[i], function (e) {
                        e.stopPropagation();
                    });
                }

                var downX, downY, dragging, dragShadow;

                widget.addEventListener("contextmenu", function (event) {
                    event.preventDefault();
                    openSidebar(id);
                });

                widget.addEventListener("mousedown", function (event) {
                    if (event.ctrlKey) {
                        event.preventDefault();
                        var widgetCopy = createWidget(x, y, width, height);

                        widgetCopy.type = selfWidget.type;
                        widgetCopy.config = JSON.parse(JSON.stringify(selfWidget.config));
                        widgetCopy.state = {};

                        widgetTypes[widgetCopy.type].init(widgetCopy.content, widgetCopy.state, widgetCopy.config, widgetCopy.box);
                    }
                    downX = mouseX, downY = mouseY;
                    dragging = true;
                    draggedWidget = widget;
                });
                document.addEventListener("mousemove", function (event) {
                    if (dragging) {
                        event.preventDefault();
                        if (!dragShadow) dragShadow = makeDragShadow();

                        var shadowX = x + (mouseX - downX);
                        var shadowY = y + (mouseY - downY);

                        dragShadow.style.gridColumn = shadowX + " / " + (shadowX + width);
                        dragShadow.style.gridRow = shadowY + " / " + (shadowY + height);
                    }
                });
                function stopDrag(event) {
                    if (dragShadow && dragShadow.parentElement) {
                        dragShadow.parentElement.removeChild(dragShadow);
                        dragShadow = undefined;
                    }

                    if (dragging && (mouseX - downX != 0 || mouseY - downY != 0)) {
                        x += (mouseX - downX);
                        y += (mouseY - downY);

                        y = Math.max(y, 0);
                        x = Math.max(x, 0);

                        widget.style.gridColumn = (x) + " / " + (x + width);
                        widget.style.gridRow = (y) + " / " + (y + height);
                    }
                    dragging = false;
                }
                document.addEventListener("mouseup", stopDrag);
                widget.addEventListener("mouseup", stopDrag);
            })();

            widget.appendChild(widgetInner);

            widgetsParent.appendChild(widget)

            return selfWidget;
        }
        function createWidgetToolbar(id, parent) {
            var toolbar = document.createElement("nav");
            toolbar.classList.add("widget--toolbar");

            var settingsButton = document.createElement("button");
            settingsButton.setAttribute("aria-label", "Settings");
            settingsButton.classList.add("widget--toolbar--settings-button")
            settingsButton.addEventListener("click", function () {
                openSidebar(id);
            });
            toolbar.appendChild(settingsButton);

            var deleteButton = document.createElement("button");
            deleteButton.setAttribute("aria-label", "Remove Widget");
            deleteButton.classList.add("widget--toolbar--delete-button")
            deleteButton.addEventListener("click", function () {
                var widgetParent = widgetsReg[id].widget;
                if (widgetParent.parentElement) {
                    widgetParent.parentElement.removeChild(widgetParent);
                    delete widgetsReg[id];
                }
            });

            toolbar.appendChild(deleteButton);
            parent.appendChild(toolbar);

            return toolbar;
        }
        function createWidgetContent(id, parent) {
            var content = document.createElement("div");
            content.classList.add("widget--content");
            parent.appendChild(content);
            return content;
        }
        function makeDragShadow() {
            var shadow = document.createElement("div");
            shadow.classList.add("drag-shadow");
            document.getElementById("grid-ui").appendChild(shadow);
            return shadow;
        }

        var openSidebar, closeSidebar;
        (function sidebar() {
            var sidebarInited = false, sidebarFocusedWidgetId, sidebarOpen;
            openSidebar = function openSidebar(id) {
                if (!sidebarInited) initSidebar();
                if (sidebarOpen) closeSidebar();

                sidebarFocusedWidgetId = id;

                var sidebarParent = document.getElementById("config-sidebar-parent");
                var sidebar = document.getElementById("config-sidebar");

                sidebar.innerHTML = "";
                populateSidebar(id, sidebar);

                sidebarParent.style.display = "block";
                sidebar.setAttribute("open", "true");
                sidebar.focus();

                sidebarOpen = true;
            }
            closeSidebar = function closeSidebar() {
                if (!sidebarInited) initSidebar();

                if (!sidebarOpen) return false;

                var sidebarParent = document.getElementById("config-sidebar-parent");
                var sidebar = document.getElementById("config-sidebar");
                sidebarParent.style.display = "none";
                sidebar.removeAttribute("open");

                sidebarOpen = false;

                if (sidebarFocusedWidgetId && widgetsReg[sidebarFocusedWidgetId]) widgetsReg[sidebarFocusedWidgetId].widget.focus();
                sidebarFocusedWidgetId = undefined;
            }
            function initSidebar() {
                var sidebarParent = document.getElementById("config-sidebar-parent");

                var pointerEvents = ["click", "dblclick", "mousedown"];

                for (var i = 0; i < pointerEvents.length; i++) {
                    sidebarParent.addEventListener(pointerEvents[i], function (e) {
                        e.stopPropagation();
                    });
                }

                sidebarParent.addEventListener("click", function (e) {
                    if (e.target == sidebarParent) closeSidebar();
                });

                document.addEventListener("keyup", function escapeListener(e) {
                    if (e.which == 27 || e.key == "Escape" || e.code == "Escape") closeSidebar();
                });

                sidebarInited = true;

            }

            function populateSidebar(id, sidebar) {

                var typeSelect = document.createElement("select");
                var settings = document.createElement("fieldset");
                settings.classList.add("sidebar--config-fields");

                var keys = Object.keys(widgetTypes);
                for (var i = 0; i < keys.length; i++) {
                    var opt = document.createElement("option");
                    if (keys[i] == widgetsReg[id].type) opt.selected = true;
                    opt.textContent = keys[i];
                    typeSelect.appendChild(opt);
                }
                typeSelect.addEventListener("change", function () {
                    widgetsReg[id].type = keys[typeSelect.selectedIndex] || "none";
                    widgetsReg[id].state = {};
                    widgetsReg[id].config = {};
                    widgetsReg[id].content.innerHTML = "";
                    widgetsReg[id].content.className = "widget--content";
                    widgetTypes[widgetsReg[id].type].init(widgetsReg[id].content, widgetsReg[id].state, widgetsReg[id].config, widgetsReg[id].box);

                    populateSidebarConfig(id, settings);
                });
                var label = document.createElement("label");
                label.textContent = "Widget Type: ";
                label.appendChild(typeSelect)
                sidebar.appendChild(label);

                sidebar.appendChild(document.createElement("hr"));


                populateSidebarConfig(id, settings);
                sidebar.appendChild(settings);
            }

            function populateSidebarConfig(id, sidebar) {
                var type = widgetTypes[widgetsReg[id].type];
                var config = type.config || [];

                if (config.length == 0) sidebar.classList.add("no-settings");
                else sidebar.classList.remove("no-settings");

                sidebar.innerHTML = "";

                for (var i = 0; i < config.length; i++) {
                    var configOption = config[i]
                    var lbl = document.createElement("label");
                    lbl.textContent = configOption.name + ": ";

                    if (configOption.type == "select") {
                        if (configOption.value == "field") {
                            lbl.appendChild(
                                createSelectControl(widgetsReg[id].config, configOption.name, fields)
                            );
                        }
                    } else if (configOption.type == "number") {

                        lbl.appendChild(
                            createNumberControl(widgetsReg[id].config, configOption.name, configOption.default)
                        );
                    }

                    sidebar.appendChild(lbl);
                }
            }
        })();

        function createSelectControl(config, key, options) {
            var select = document.createElement("select");

            if (config[key] === undefined) config[key] = options[0];

            for (var i = 0; i < options.length; i++) {
                var opt = document.createElement("option");
                if (config[key] === options[i]) opt.setAttribute("selected", "true");
                opt.textContent = options[i];
                select.appendChild(opt);
            }
            select.addEventListener("change", function () {
                config[key] = options[select.selectedIndex];
            });
            return select;
        }

        function createNumberControl(config, key, defaultValue) {
            if (config[key] === undefined) {
                config[key] = defaultValue || 0;
            }
            var input = document.createElement("input");
            input.type = "number";
            input.value = config[key];
            input.addEventListener("change", function () {
                config[key] = input.valueAsNumber;
            });

            return input;
        }

        function startDataRequest() {
            var xhr = new XMLHttpRequest();

            xhr.open("GET", "/stream");

            var lastIndex = -1;
            xhr.addEventListener("progress", function (event) {
                var currentIndex = xhr.responseText.length;
                if (lastIndex == currentIndex) return; // No new data
                var streamData = xhr.responseText.substring(lastIndex, currentIndex);

                var streamChunks = streamData.split("\n");
                for (var i = 0; i < streamChunks.length; i++) {
                    if (streamChunks[i].startsWith("{")) processData(streamChunks[i]);
                    else console.log("Control code: " + streamChunks[i]);
                }

                lastIndex = currentIndex;
            });

            xhr.send();

            //abort & restart after 30s
            setTimeout(function () {
                xhr.abort();
                startDataRequest();
            }, 30000);
        }

        function processData(data) {
            var dataObject = {};
            try {
                dataObject = JSON.parse(data);
            } catch (e) {
                console.error(data);
                console.error(e);
            }
            if (dataObject.fields !== undefined) fields = Object.keys(dataObject.fields);
            var widgets = Object.values(widgetsReg);
            for (var i = 0; i < widgets.length; i++) {
                //skip `__continue`
                if (typeof widgets[i] == "number") continue;

                try {
                    widgetTypes[widgets[i].type].ondata(dataObject, widgets[i].content, widgets[i].state, widgets[i].config);
                } catch (e) {
                    console.error(e);
                    console.error(widgets[i]);
                }
            }
        }

        function drawLine(datapoints, box, xScale, isFilled) {
            var firstDisplayedDatapointIndex = 0;
            var xRightEdge = Date.now();

            //find the first displayed datapoint. If there's not enough data to cover the graph, it'll select everything.
            for (var i = datapoints.length - 1; i >= 0; i--) {
                var pointAge = (xRightEdge - datapoints[i].x);
                if (pointAge > xScale) {
                    firstDisplayedDatapointIndex = i + 1;
                    break;
                }
            }

            //slice out data that matters
            var displayedData = datapoints.slice(firstDisplayedDatapointIndex);

            //find top point
            var max = displayedData[0].y;
            for (var i = 0; i < displayedData.length; i++) max = Math.max(max, displayedData[i].y);

            var path = "";

            for (var i = 0; i < displayedData.length; i++) {
                var point = displayedData[i];

                var x = 1 - ((xRightEdge - point.x) / xScale);
                var y = (max - point.y) / max;

                //initialization
                if (i == 0) path += "M" + (x * box.width) + "," + (y * box.height);

                path += "L" + (x * box.width) + "," + (y * box.height);
            }
            return path;
        }

    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            background: var(--background-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body.dark-theme {
            --widget-text-color: #EFF9FB;
            --widget-background-color: #1B1D22;
            --background-color: #2A2D34;
            --grid-color: #EFF9FB;
            --widget-inner-background-color: #24272D;
            --close-widget-color: #C23838;
            --widget-settings-color: #0092CC;
            --sidebar-lightbox: #1B1D22cc;
            --data-green: #10BC8B;
            --graph-label: #3E4247;
        }

        body.light-theme {
            --widget-text-color: #1e1f1f;
            --widget-background-color: #98A0AE;
            --background-color: #B0B4BF;
            --grid-color: #090A0B;
            --widget-inner-background-color: #d4d4d4;
            --close-widget-color: #B22E2E;
            --widget-settings-color: #0075A3;
            --sidebar-lightbox: #98A0AEcc;
            --data-green: #007a58;
            --graph-label: #a8a8a8;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, var(--grid-size));
            grid-template-rows: repeat(auto-fill, var(--grid-size));
            grid-gap: 0;
            gap: 0;

            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: 100vh;
        }

        #grid-background span {
            display: block;
            width: var(--grid-size);
            height: var(--grid-size);
            position: relative;
        }

        #grid-background span::before {
            width: 2px;
            height: 2px;
            background: var(--grid-color);
            content: "";
            display: inline-block;
            position: absolute;
            top: -1px;
            left: -1px;
        }

        #grid-background span::after {
            width: 2px;
            height: 2px;
            background: var(--grid-color);
            content: "";
            display: inline-block;
            position: absolute;
            bottom: -1px;
            right: -1px;
        }

        .widget {
            background: var(--widget-background-color);
            box-shadow: 0 0 0.5px 1px var(--background-color);
            padding: 5px;
        }

        .widget--inner {
            background: var(--widget-inner-background-color);
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .drag-shadow {
            background: var(--widget-background-color);
            opacity: 0.85;
            border-radius: 50px;
        }

        #grid-ui {
            pointer-events: none;
        }

        .widget:hover .widget--toolbar {
            min-height: 2em;
            padding: 0.125em;
            background-color: var(--widget-background-color);
            opacity: 1;

        }

        .widget--toolbar {
            height: 0em;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.125s;
            gap: 0.2em;
            justify-content: flex-end;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            flex-shrink: 0;
        }

        .widget--toolbar select {
            all: unset;
            color: var(--widget-text-color);
            background: inherit;
            border: 0;
            cursor: pointer;
            user-select: none;
        }

        .widget--toolbar--delete-button {
            all: unset;

            display: inline-block;

            width: 1em;
            height: 1em;


            background: var(--close-widget-color);
            border-radius: 100%;

            cursor: pointer;
            user-select: none;
        }

        .widget--toolbar--settings-button {
            all: unset;

            display: inline-block;

            width: 1em;
            height: 1em;


            background: var(--widget-settings-color);
            border-radius: 100%;

            cursor: pointer;
            user-select: none;
        }

        .widget--content {
            flex-grow: 1;
            color: var(--widget-text-color);
            overflow: auto;
            padding: 0.5em;
        }

        .widget--content.nopadding {
            padding: 0
        }

        .widget--content.nooverflow {
            overflow: hidden
        }

        .widget--content pre {
            margin: 0;
        }

        #config-sidebar {
            color: var(--widget-text-color);
            position: absolute;
            top: 0;
            height: 100vh;
            width: calc(3 * var(--grid-size));
            background: var(--widget-inner-background-color);
            display: none;
            opacity: 0;
            transition: opacity 0.25s;
            padding: 1em;
            border-right: 0.25em solid var(--widget-background-color);

            flex-direction: column;
        }

        #config-sidebar hr {
            border: 0;
            border-top: 1px solid var(--widget-text-color);
        }

        #config-sidebar[open] {
            display: flex;
            opacity: 1;
        }

        #config-sidebar[data-side=left] {
            left: 0;
        }

        #config-sidebar[data-side=right] {
            left: 0;
        }

        #config-sidebar-parent {
            position: fixed;
            top: 0;
            right: 0;
            left: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;

            display: none;

            background: var(--sidebar-lightbox);
        }

        .sidebar--config-fields {
            border: 2px solid var(--widget-background-color);
            flex-grow: 1;
        }

        .sidebar--config-fields.no-settings {
            background: var(--widget-background-color);
        }

        .widget--line-chart {
            width: 100%;
            height: 100%;
        }

        .widget--line-chart--fill-line {
            fill: url(#line-graph-fill-gradient);
        }

        .widget--line-chart--stroke-line {
            stroke: var(--data-green);
            stroke-width: 0.125em;
            stroke-linejoin: round;
            fill: transparent;
            stroke-linecap: round;
        }

        .widget--line-chart--caption-line {
            stroke: var(--graph-label);
            stroke-width: 0.25em;
            stroke-linecap: round;
        }

        .widget--line-chart--caption {
            fill: var(--graph-label);
            font: inherit;
            font-size: 1.85em;
        }

        #line-graph-fill-gradient-color {
            stop-color: var(--data-green);
        }

    </style>
</head>

<body>
    <svg style="width:0;height:0;position:absolute;" aria-hidden="true" focusable="false">
        <linearGradient id="line-graph-fill-gradient" x2="0" y2="1">
            <stop offset="0%" stop-color="#447799" id="line-graph-fill-gradient-color" />
            <stop offset="100%" stop-color="#0000" id="line-graph-fill-bg-color" />
        </linearGradient>
    </svg>

    <div aria-hidden="true" class="grid" id="grid-background"></div>
    <div class="grid" id="grid-widgets"></div>
    <div aria-hidden="true" class="grid" id="grid-ui"></div>
    <div id="config-sidebar-parent">
        <sidebar id="config-sidebar" data-side="left"></sidebar>
    </div>
    <script>
        if (location.search == "?paul") localStorage.setItem("theme", "light");
        else if (location.search == "?unpaul") localStorage.setItem("theme", "dark")

        document.body.classList.add((localStorage.getItem("theme") || "dark") + "-theme");
    </script>
</body>

</html>