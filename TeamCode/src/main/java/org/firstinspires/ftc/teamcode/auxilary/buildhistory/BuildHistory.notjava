package org.firstinspires.ftc.teamcode.auxilary.buildhistory;

import java.time.Instant;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import org.firstinspires.ftc.teamcode.auxilary.FileSaver;
import org.jetbrains.annotations.NotNull;

public class BuildHistory {
    public static String builderBrowserFingerprint = "BUILDER_BROWSER_FINGERPRINT";
    public static String buildTimeIso = "BUILD_TIME_ISO";
    public static String buildName = "BUILD_NAME";
    public static String buildHistory = "BUILD_HISTORY";

    public static final String MEMORY_FILE = "build-history.csv";
    public static final int MOST_RECENT_INCLUDE_NUM = 200;

    public static void init() {
        loadLocalMemory();
    }
    private static void loadLocalMemory() {
        FileSaver localFile = new FileSaver(MEMORY_FILE);
        String localFileContent = String.join("\n", localFile.readLines());

        String[][] localBuildTable = parseCsvToTable(localFileContent);
        String[][] builtBuildTable = getBuildHistoryAsTable();

        HashMap<String, String> records = new HashMap<>();

        for(String[] row : builtBuildTable) records.put(row[0], row[1]);
        for(String[] row : localBuildTable) records.put(row[0], row[1]);


        Set<Map.Entry<String, String>> entrySet = records.entrySet();

        //find smallest & greatest nano-times
        long minNano = Long.MAX_VALUE, maxNano = Long.MIN_VALUE;
        for(Map.Entry<String, String> entry: entrySet) {
            Instant instant = Instant.parse(entry.getValue());
            long nano = instant.getEpochSecond() + instant.getNano();
            if(nano > maxNano) maxNano = nano;
            if(nano < minNano) minNano = nano;
        }

        long nanoRange = maxNano - minNano;

        //copy over to an array
        BuildMemoryData[] rowData = new BuildMemoryData[builtBuildTable.length + localBuildTable.length];
        int index = 0;
        for(Map.Entry<String, String> entry : entrySet) {
            rowData[index] = new BuildMemoryData(entry.getKey(), Instant.parse(entry.getValue()), entry.getValue());
        }

        //sort ascending
        for(int i = 0; i < rowData.length; i++) {
            long maxTime = rowData[i].getTime().getEpochSecond();
            int maxIndex = i;

            for(int j = i + 1; j < rowData.length; j++) {
                if(rowData[j].getTimeEpoch() > maxTime) {
                    maxTime = rowData[j].getTimeEpoch();
                    maxIndex = j;
                }
            }
            if(maxIndex != i) {
                BuildMemoryData swap = rowData[i];
                rowData[i] = rowData[maxIndex];
                rowData[maxIndex] = swap;
            }
        }

        //only include the most recent 200 values
        String[] sliceRows = new String[Math.min(rowData.length, MOST_RECENT_INCLUDE_NUM)];
        for(int i = sliceRows.length - 1; i >= 0; i--) {
            sliceRows[i] = rowData[i + (rowData.length - sliceRows.length)].toString();
        }

        //save values, both in the file and in the static variable so that others can have up-to-date data
        String content = String.join("\n", sliceRows);
        localFile.overwriteFile(content);
        buildHistory = content;
    }
    public static String[][] getBuildHistoryAsTable() {
        return parseCsvToTable(buildHistory);
    }

    private static String[][] parseCsvToTable(String csv) {
        String[] rows = csv.split("\n");
        String[][] table = new String[rows.length][];

        for(int i = 0; i < rows.length; i++) {
            table[i] = rows[i].split(",");
        }
        return table;
    }
    private static class BuildMemoryData {
        public String name;
        public Instant time;
        public String isoTime;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public Instant getTime() {
            return time;
        }

        public void setTime(Instant time) {
            this.time = time;
        }

        public String getIsoTime() {
            return isoTime;
        }

        public void setIsoTime(String isoTime) {
            this.isoTime = isoTime;
        }

        public BuildMemoryData(String name, Instant time, String isoTime) {
            this.name = name;
            this.time = time;
            this.isoTime = isoTime;
        }

        public long getTimeEpoch() {
            return this.time.getEpochSecond();
        }

        @NotNull
        public String toString() {
            return this.name = "," + this.isoTime;
        }
    }
}
